#!/usr/bin/env python3
# scripts/check_i18n.py
import ast
import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

KNOWN_TRANSLATION_FUNCS = {
    'gettext',
    'gettext_lazy',
    'ugettext',
    'ugettext_lazy',
    'ngettext',
    'ungettext',
    'ungettext_lazy',
    'pgettext',
    '_',
}

DEFAULT_IGNORES = [
    '.git',
    '.venv',
    'venv',
    'env',
    '.tox',
    '.ruff_cache',
    '.pytest_cache',
    'node_modules',
    'static',
    'media',
    'dist',
    'build',
    'migrations',
    'tests',
    '__pycache__',
    '.mypy_cache',
    'staticfiles',
    'scripts',
]

EXCLUDE_PATTERNS = [
    r'^[a-z_][a-z0-9_]*$',
    r'^[A-Z_][A-Z0-9_]*$',
    r'^\w+\.\w+',
    r'^[/<>@#$%^&*()+=\[\]{}|\\:;,.<>?~`-]+$',
    r'^\d+$',
    r'^[a-z]+://',
    r'^\s*$',
    r'^\{\{.*\}\}$',
    r'^\{\{.*',
    r'^</?[^>]+>$',
    r'^pages/.*\.html$',
    r'^Generated by .django-admin.',
    r'^Command not found',
    r'^Running:',
    r'^URL configuration for',
    r'^The `urlpatterns` list',
    r'^Django settings for',
    r'^Create a superuser',
    r'^Create and save a user',
    r'^The Email field must be set',
    r'^Admin view for',
    r'^Manager for',
    r'^Custom user model',
    r'^i18n/',
    r'^admin/',
    r'^accounts/',
    r'^\.env$',
    r'^en-gb$',
    r'^static/',
    r'^email\*$',
    r'^password1\*$',
    r'^password2\*$',
    r'^frontend/build',
    r'^manifest\.json$',
]
SUPPORTED_SUFFIXES = {'.py', '.html', '.htm', '.txt'}

MIN_STRING_LENGTH = 3
MIN_WORD_LENGTH = 4
MAX_EXAMPLE_LENGTH = 30
MIN_NODE_STR_LENGTH = 10
MIN_ATTR_TEXT_LENGTH = 2

DJANGO_AVAILABLE = False
I18N_NODES_AVAILABLE = False

Template = None  # type: ignore[assignment]
TextNode = None  # type: ignore[assignment]
CommentNode = None  # type: ignore[assignment]

try:
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
        print(f'üîß Added project root to sys.path: {project_root}')

    manage_py = project_root / 'manage.py'
    settings_module = None
    if manage_py.exists():
        with open(manage_py, encoding='utf-8') as f:
            content = f.read()
            pattern = (
                r'os\.environ\.setdefault\('
                r"'DJANGO_SETTINGS_MODULE',\s*'([^']+)'\)"
            )
            match = re.search(pattern, content)
            if match:
                settings_module = match.group(1)
                print(
                    f'üîç Detected settings module from manage.py: '
                    f'{settings_module}'
                )

    possible_settings = [settings_module] if settings_module else []
    if not settings_module:
        possible_settings = [
            'core.settings',
            'forenlims.core.settings',
            'forenlims.settings',
            'project.settings',
        ]

    for ps in possible_settings:
        if ps:
            try:
                __import__(ps.split('.')[0])
                settings_module = ps
                print(f'üîç Verified settings module: {settings_module}')
                break
            except ImportError:
                continue

    if not settings_module:
        settings_candidates = list(project_root.glob('**/settings.py'))
        candidates_str = [str(p.parent) for p in settings_candidates]
        print(
            f'‚ö†Ô∏è  No valid settings module found. '
            f'Possible settings.py files: {candidates_str}'
        )
        print(f'   sys.path[0]: {sys.path[0]}')
        print(
            '   üí° Try adjusting possible_settings list '
            "(e.g., add 'your_project.settings')"
        )
        raise ImportError('Could not find valid settings module')

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)
    import django

    django.setup()

    from django.template import Template
    from django.template.base import TextNode

    try:
        from django.template.defaulttags import (
            CommentNode,
        )
    except ImportError:
        from django.template.base import CommentNode

    try:
        import importlib.util

        if importlib.util.find_spec('django.templatetags.i18n'):
            I18N_NODES_AVAILABLE = True
            print('‚úÖ i18n nodes available')
    except ImportError:
        I18N_NODES_AVAILABLE = False
        print(
            '‚ö†Ô∏è  i18n nodes not directly importable - '
            'using fallback extraction'
        )

    DJANGO_AVAILABLE = True
    print('‚úÖ Django loaded and ready for full template parsing')

except Exception as e:
    print(
        f'‚ö†Ô∏è  Django setup failed: {e} - '
        'using regex fallback for templates'
    )
    DJANGO_AVAILABLE = False


def load_i18nignore(root: Path) -> Set[str]:
    ignore_file = root / '.i18nignore'
    ignored = set(DEFAULT_IGNORES)
    if ignore_file.exists():
        for raw_line in ignore_file.read_text(encoding='utf-8').splitlines():
            line = raw_line.strip()
            if line and not line.startswith('#'):
                ignored.add(line)
    return ignored


def should_exclude_string(s: str) -> bool:
    s = s.strip()
    if len(s) < MIN_STRING_LENGTH:
        return True
    for pattern in EXCLUDE_PATTERNS:
        if re.match(pattern, s, re.IGNORECASE):
            return True
    return False


def clean_template_text(raw_text: str) -> str:
    text = re.sub(
        r'<!--.*?-->',
        '',
        raw_text,
        flags=re.DOTALL | re.IGNORECASE,
    )
    text = re.sub(r'\{%.*?%\}', '', text, flags=re.DOTALL)
    text = re.sub(r'\{\{[^}]*\}\}', '', text, flags=re.DOTALL)
    text = re.sub(r'<[^>]+>', '', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text


def extract_phrases_from_text(clean_text: str) -> List[str]:
    phrases = re.findall(
        r'\b[a-zA-Z]{2,}(?:\s+[a-zA-Z]{2,})+\b',
        clean_text,
        re.IGNORECASE,
    )
    if not phrases:
        words = re.findall(
            r'\b[a-zA-Z]{4,}\b',
            clean_text,
            re.IGNORECASE,
        )
        phrases = words[:2]
    return [p.strip() for p in phrases if not should_exclude_string(p)]


def check_python_file(path: Path) -> List[Tuple[int, str]]:
    unmarked = []
    try:
        content = path.read_text(encoding='utf-8')
        tree = ast.parse(content, filename=str(path))
    except (SyntaxError, UnicodeDecodeError):
        print(f'‚ö†Ô∏è  Skipped broken file: {path}')
        return unmarked

    translation_aliases: Dict[str, Set[str]] = {}

    class ImportCollector(ast.NodeVisitor):
        def visit_Import(self, node: ast.Import) -> None:
            for alias in node.names:
                is_gettext = alias.name == 'gettext'
                is_django_trans = alias.name.startswith(
                    'django.utils.translation'
                )
                if is_gettext or is_django_trans:
                    local_name = alias.asname or alias.name.split('.')[-1]
                    translation_aliases[local_name] = (
                        KNOWN_TRANSLATION_FUNCS.copy()
                    )
            self.generic_visit(node)

        def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
            module = node.module
            if module in ('gettext', 'django.utils.translation'):
                for alias in node.names:
                    imported_name = alias.name
                    local_name = alias.asname or imported_name
                    if imported_name in KNOWN_TRANSLATION_FUNCS:
                        if local_name not in translation_aliases:
                            translation_aliases[local_name] = set()
                        translation_aliases[local_name].add(imported_name)
            self.generic_visit(node)

    import_collector = ImportCollector()
    import_collector.visit(tree)

    translated_strings = set()

    class TranslationCollector(ast.NodeVisitor):
        def visit_Call(self, node: ast.Call) -> None:
            is_translation_call = False

            if isinstance(node.func, ast.Name):
                func_name = node.func.id
                if translation_aliases.get(func_name):
                    is_translation_call = True
            elif isinstance(node.func, ast.Attribute):
                attr_name = node.func.attr
                if isinstance(node.func.value, ast.Name):
                    value_name = node.func.value.id
                    if value_name in translation_aliases:
                        attr_in_aliases = (
                            attr_name in translation_aliases[value_name]
                        )
                        if attr_in_aliases:
                            is_translation_call = True

            if is_translation_call:
                for arg in node.args:
                    is_str_constant = isinstance(
                        arg, ast.Constant
                    ) and isinstance(arg.value, str)
                    if is_str_constant:
                        translated_strings.add(arg.value)

            self.generic_visit(node)

    collector = TranslationCollector()
    collector.visit(tree)

    class StringFinder(ast.NodeVisitor):
        def visit_Constant(self, node: ast.Constant) -> None:
            if isinstance(node.value, str):
                s = node.value
                not_translated = s not in translated_strings
                not_excluded = not should_exclude_string(s)
                if not_translated and not_excluded:
                    unmarked.append((node.lineno, s))
            self.generic_visit(node)

    finder = StringFinder()
    finder.visit(tree)

    return unmarked


def find_approx_line(content: str, text: str) -> Optional[int]:
    lines = content.splitlines()
    for i, line in enumerate(lines, 1):
        if text.lower() in line.lower():
            return i
    return None


def check_template_file(path: Path) -> List[Tuple[int, str]]:
    unmarked = []
    try:
        content = path.read_text(encoding='utf-8')
    except UnicodeDecodeError:
        return unmarked

    print(f'üìÑ Checking template: {path.name} (using Django)')

    if not DJANGO_AVAILABLE:
        print('   Falling back to regex (Django not available)')
        return _regex_template_check(content, path)

    try:
        unmarked = _django_template_check(content, path)
    except Exception as e:
        print(
            f'‚ö†Ô∏è  Django parsing error in {path.name}: {e} - '
            'using regex fallback'
        )
        unmarked = _regex_template_check(content, path)

    return unmarked


def _extract_translated_strings(content: str) -> Set[str]:
    """Extract translated strings from template using regex."""
    translated_strings = set()

    trans_pattern = re.compile(
        r'{%\s*trans\s+["\']([^"\']+?)["\']\s*%}',
        re.IGNORECASE | re.DOTALL,
    )
    blocktrans_pattern = re.compile(
        r'{%\s*blocktrans\s*.*?%}(.*?){%\s*endblocktrans\s*%}',
        re.DOTALL | re.IGNORECASE,
    )
    for match in trans_pattern.finditer(content):
        ts = match.group(1).strip()
        if len(ts) > MIN_STRING_LENGTH:
            translated_strings.add(ts)
    for match in blocktrans_pattern.finditer(content):
        block_content = match.group(1).strip()
        plain_block = clean_template_text(block_content)
        phrases = extract_phrases_from_text(plain_block)
        translated_strings.update(
            [p for p in phrases if len(p) > MIN_STRING_LENGTH]
        )
    return translated_strings


def _extract_attribute_texts(content: str) -> List[Tuple[int, str]]:
    """Extract text from HTML attributes."""
    attr_patterns = [
        (
            r'(?:title|alt|value|placeholder|name|label|aria-label|for)'
            r'\s*=\s*["\']([^"\']{3,})["\']'
        ),
        r'data-[^=]+\s*=\s*["\']([^"\']{3,})["\']',
    ]
    attr_texts = []
    for pattern in attr_patterns:
        for match in re.finditer(
            pattern,
            content,
            re.IGNORECASE | re.DOTALL,
        ):
            text = match.group(1).strip()
            is_long_enough = len(text) > MIN_STRING_LENGTH
            has_no_var = '{{' not in text
            not_excluded = not should_exclude_string(text)
            if is_long_enough and has_no_var and not_excluded:
                line_num = find_approx_line(content, text) or 1
                attr_texts.append((line_num, text))
    return attr_texts


def _extract_translated_nodes(
    node,  # noqa: ANN001
    translated_strings: Set[str],
) -> None:
    """Extract translated nodes from template recursively."""
    node_str = str(node).strip()
    has_trans = (
        'trans' in node_str.lower() or 'blocktrans' in node_str.lower()
    )
    if len(node_str) > MIN_NODE_STR_LENGTH and has_trans:
        matches = re.findall(r'["\']([^"\']{3,})["\']', node_str)
        for m in matches:
            clean_m = clean_template_text(m)
            is_long_enough = len(clean_m) > MIN_STRING_LENGTH
            not_excluded = not should_exclude_string(clean_m)
            no_object = 'object' not in clean_m
            if is_long_enough and not_excluded and no_object:
                translated_strings.add(clean_m)
    if hasattr(node, 'nodelist'):
        for child in node.nodelist:
            _extract_translated_nodes(child, translated_strings)


def _extract_text_nodes(
    node,  # noqa: ANN001
    content: str,
    potential_unmarked: List[Tuple[int, str]],
) -> None:
    """Extract text nodes from template recursively."""
    if isinstance(node, TextNode):
        raw = node.s
        clean = clean_template_text(raw)
        phrases = extract_phrases_from_text(clean)
        for phrase in phrases:
            if len(phrase) > MIN_STRING_LENGTH:
                line_num = find_approx_line(content, phrase) or 1
                potential_unmarked.append((line_num, phrase))
    elif isinstance(node, CommentNode):
        pass
    if hasattr(node, 'nodelist'):
        for child in node.nodelist:
            _extract_text_nodes(child, content, potential_unmarked)


def _print_django_results(
    potential_unmarked: List[Tuple[int, str]],
    translated_strings: Set[str],
    unmarked: List[Tuple[int, str]],
) -> None:
    """Print Django template check results."""
    clean_translated = [
        t
        for t in translated_strings
        if len(t) > MIN_STRING_LENGTH and not should_exclude_string(t)
    ]

    print(
        f'   Django: {len(potential_unmarked)} texts found, '
        f'{len(clean_translated)} translated, {len(unmarked)} unmarked'
    )
    if clean_translated:
        examples = ', '.join(clean_translated[:2])
        print(f'   Translated examples: {examples}')
    if unmarked:
        examples = [
            (
                text[:MAX_EXAMPLE_LENGTH] + '...'
                if len(text) > MAX_EXAMPLE_LENGTH
                else text
            )
            for _, text in unmarked[:2]
        ]
        print(f'   Unmarked examples: {", ".join(examples)}')


def _filter_unmarked_strings(
    potential_unmarked: List[Tuple[int, str]],
    translated_strings: Set[str],
) -> List[Tuple[int, str]]:
    """Filter and deduplicate unmarked strings."""
    seen = set()
    unmarked = []
    for line_num, text in potential_unmarked:
        not_in_translated = text not in translated_strings
        not_in_seen = text not in seen
        not_excluded = not should_exclude_string(text)
        if not_in_translated and not_in_seen and not_excluded:
            unmarked.append((line_num, text))
            seen.add(text)
    return unmarked


def _django_template_check(
    content: str,
    path: Path,
) -> List[Tuple[int, str]]:
    """Check template using Django parser."""
    template = Template(content)
    translated_strings = _extract_translated_strings(content)
    potential_unmarked: List[Tuple[int, str]] = []

    attr_texts = _extract_attribute_texts(content)
    print(f'   Found {len(attr_texts)} attributes')

    if hasattr(template, 'nodelist') and template.nodelist:
        _extract_translated_nodes(
            template.nodelist[0],
            translated_strings,
        )
        _extract_text_nodes(
            template.nodelist[0],
            content,
            potential_unmarked,
        )

    potential_unmarked.extend(attr_texts)
    unmarked = _filter_unmarked_strings(
        potential_unmarked,
        translated_strings,
    )
    _print_django_results(potential_unmarked, translated_strings, unmarked)

    return unmarked


def _extract_regex_translated(content: str) -> Set[str]:
    """Extract translated strings using regex patterns."""
    trans_pattern = re.compile(
        r'{%\s*trans\s+["\']([^"\']+?)["\']\s*%}',
        re.IGNORECASE | re.DOTALL,
    )
    blocktrans_pattern = re.compile(
        r'{%\s*blocktrans\s*.*?%}(.*?){%\s*endblocktrans\s*%}',
        re.DOTALL | re.IGNORECASE,
    )

    translated = set()
    for match in trans_pattern.finditer(content):
        translated.add(match.group(1).strip())
    for match in blocktrans_pattern.finditer(content):
        block_content = match.group(1).strip()
        plain_text = re.sub(
            r'\{\{[^}]*\}\}',
            '',
            block_content,
            flags=re.DOTALL,
        )
        plain_text = re.sub(
            r'\{%.*?%\}',
            '',
            plain_text,
            flags=re.DOTALL,
        )
        plain_text = re.sub(r'<[^>]+>', '', plain_text)
        plain_text = re.sub(
            r'<!--.*?-->',
            '',
            plain_text,
            flags=re.DOTALL,
        )
        plain_text = re.sub(r'\s+', ' ', plain_text).strip()
        if plain_text and len(plain_text.split()) >= 1:
            translated.add(plain_text)
    return translated


def _extract_regex_phrases(
    content_clean: str,
) -> List[Tuple[int, str]]:
    """Extract potential phrases from cleaned content."""
    potential_phrases = []
    lines = content_clean.splitlines()
    for line_num, line in enumerate(lines, 1):
        phrases = re.findall(
            r'\b[a-zA-Z]{2,}(?:\s+[a-zA-Z]{2,})+\b',
            line,
            re.IGNORECASE,
        )
        for phrase in phrases:
            if not should_exclude_string(phrase):
                potential_phrases.append((line_num, phrase))
        if not phrases:
            single_words = re.findall(
                r'\b[a-zA-Z]{4,}\b',
                line,
                re.IGNORECASE,
            )
            for word in single_words[:1]:
                if not should_exclude_string(word) and '{{' not in word:
                    potential_phrases.append((line_num, word))
    return potential_phrases


def _regex_template_check(
    content: str,
    path: Path,
) -> List[Tuple[int, str]]:
    """Fallback regex-based template check."""
    translated = _extract_regex_translated(content)

    if translated:
        examples = ', '.join(list(translated)[:2])
        print(f'   Regex translated examples: {examples}')

    content_clean = re.sub(
        r'<!--.*?-->',
        '',
        content,
        flags=re.DOTALL | re.IGNORECASE,
    )
    content_clean = re.sub(
        r'\{%.*?%\}',
        '',
        content_clean,
        flags=re.DOTALL,
    )
    content_clean = re.sub(
        r'\{\{[^}]*\}\}',
        '',
        content_clean,
        flags=re.DOTALL,
    )
    content_clean = re.sub(r'<[^>]+>', '', content_clean)
    content_clean = re.sub(r'\s+', ' ', content_clean)

    attr_patterns = [
        (
            r'(?:title|alt|value|placeholder|name|label|aria-label)'
            r'\s*=\s*["\']([^"\']+)["\']'
        ),
    ]
    attr_texts = []
    for pattern in attr_patterns:
        for match in re.finditer(
            pattern,
            content,
            re.IGNORECASE | re.DOTALL,
        ):
            text = match.group(1).strip()
            if len(text) > MIN_ATTR_TEXT_LENGTH and '{{' not in text:
                attr_texts.append(text)

    potential_phrases = _extract_regex_phrases(content_clean)

    seen_texts = {text for _, text in potential_phrases}
    for text in attr_texts:
        if text not in seen_texts:
            line_num = find_approx_line(content, text) or 1
            potential_phrases.append((line_num, text))

    seen = set()
    unmarked = []
    for line_num, text in potential_phrases:
        not_in_translated = text not in translated
        not_excluded = not should_exclude_string(text)
        not_in_seen = text not in seen
        if not_in_translated and not_excluded and not_in_seen:
            refined_line = find_approx_line(content, text)
            unmarked.append((refined_line or line_num, text))
            print(
                f'   Regex: {len(potential_phrases)} phrases found, '
                f'{len(translated)} translated, {len(unmarked)} unmarked'
            )

    return unmarked


def scan_project(
    root: str = '.',
    ignored: Optional[Set[str]] = None,
) -> List[str]:
    root_path = Path(root)
    if ignored is None:
        ignored = load_i18nignore(root_path)

    results = []
    py_count = 0
    template_count = 0
    py_unmarked = 0
    template_unmarked = 0

    candidate_paths = []
    for path in root_path.rglob('*'):
        if path.suffix.lower() not in SUPPORTED_SUFFIXES:
            continue

        if any(ignored_part in path.parts for ignored_part in ignored):
            continue

        if not path.is_file():
            continue

        try:
            _ = path.read_text(encoding='utf-8', errors='ignore')
        except Exception:
            print(f'‚ö†Ô∏è  Skipped non-text file: {path}')
            continue

        candidate_paths.append(path)

    print(f'üîç Found {len(candidate_paths)} candidate files to scan')

    for path in candidate_paths:
        unmarked = []

        if path.suffix == '.py':
            py_count += 1
            unmarked = check_python_file(path)
            py_unmarked += len(unmarked)
        elif path.suffix in {'.html', '.htm'}:
            template_count += 1
            unmarked = check_template_file(path)
            template_unmarked += len(unmarked)

        for line_num, string in unmarked:
            results.append(f'{path}:{line_num}: {string[:80]}')

    print(
        f'\nüìä Scanned {py_count} Python files ({py_unmarked} unmarked), '
        f'{template_count} templates ({template_unmarked} unmarked)'
    )
    return results


if __name__ == '__main__':
    print('üîç Scanning for unmarked i18n strings...\n')
    strings = scan_project()

    if strings:
        print(f'‚ö†Ô∏è  Found {len(strings)} potentially unmarked strings:\n')
        for s in strings:
            print(s)
        print(
            f'\nüí° Total: {len(strings)} strings need review '
            '(review for gettext or {% trans %})'
        )
    else:
        print('‚úÖ No unmarked strings found!')
